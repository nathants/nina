// Token tracking types for accurate API usage monitoring and cache hit ratio calculation.
// These structures track only actual API-returned values, no client-side estimation.
// Used for monitoring configurable input limits and cache efficiency across providers.
package lib

// TokenUsage represents actual token counts returned by API providers
// All values come directly from API responses, no client-side estimation
type TokenUsage struct {
	Input  int // Input tokens consumed by the API
	Output int // Output tokens generated by the API
	Cache  CacheUsage
}

// CacheUsage tracks cache-related tokens for providers that support caching
// Only Anthropic Claude currently provides these metrics in API responses
type CacheUsage struct {
	Read  int // Tokens read from cache (cache hits)
	Write int // Tokens written to cache for future use
}

// UsageMetrics combines token usage with calculated metrics for monitoring
// Used to track approaching input limits and cache efficiency
type UsageMetrics struct {
	Tokens        TokenUsage
	TotalInput    int     // Input + Cache.Write (total input tokens for limit checking)
	CacheHitRatio float64 // Cache.Read / (Input + Cache.Write) * 100
}

// SessionUsage tracks cumulative usage across an entire session
// Used for monitoring total usage and approaching the configured input limit
type SessionUsage struct {
	TotalTokens      TokenUsage
	CurrentInput     int     // Current message input tokens for limit checking
	SessionInput     int     // Cumulative input tokens across all messages
	CacheHitRatio    float64 // Overall cache hit ratio for the session
	InputLimitStatus string  // "ok", "warning" (75%), "alert" (90%), "critical" (95%)
}

// CalculateUsageMetrics computes derived metrics from raw token counts
// Returns metrics including cache hit ratio and total input for limit checking
func CalculateUsageMetrics(tokens TokenUsage) UsageMetrics {
	totalInput := tokens.Input + tokens.Cache.Write
	cacheHitRatio := 0.0
	// Calculate cache efficiency: what % of needed tokens came from cache
	totalNeeded := tokens.Cache.Read + tokens.Input
	if totalNeeded > 0 && tokens.Cache.Read > 0 {
		cacheHitRatio = float64(tokens.Cache.Read) / float64(totalNeeded) * 100
	}
	return UsageMetrics{
		Tokens:        tokens,
		TotalInput:    totalInput,
		CacheHitRatio: cacheHitRatio,
	}
}

// CheckInputLimit determines the status based on current input token usage
// Returns status string and whether to show a warning to the user
func CheckInputLimit(currentInput int, maxTokens int) (status string, showWarning bool) {
	percentage := float64(currentInput) / float64(maxTokens) * 100
	
	switch {
	case percentage >= 95:
		return "critical", true
	case percentage >= 90:
		return "alert", true
	case percentage >= 75:
		return "warning", true
	default:
		return "ok", false
	}
}

// CompactionResult contains the results of a message compaction operation
// Used to track both the number of messages and tokens removed for accurate accounting
type CompactionResult struct {
	MessagesRemoved int // Number of messages removed from history
	TokensRemoved   int // Estimated input tokens from removed messages
}
